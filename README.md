# CtxBoot

A lightweight dependency injection framework for Go.

## Installation

Install the code generator:

```bash
go install github.com/iondodon/ctxboot/cmd/ctxboot@latest
```

Then you can run it from project root directory:

```bash
ctxboot .
```

## Generated Code

The code generator creates a `ctxboot.go` file in your project. Here's what it contains:

```go
// Code generated by ctxboot; DO NOT EDIT.

package main

import (
    "github.com/iondodon/ctxboot"
    "reflect"
    "log"

    // Import statements for all component packages
    "your/package/database"
    "your/package/repository"
    "your/package/service"
)

// LoadContext registers and initializes all components
func LoadContext(cc *ctxboot.ComponentContext) error {
    // Register components in dependency order
    // Database (no dependencies)
    if err := cc.SetComponent(reflect.TypeOf((*database.Database)(nil)), &database.Database{}); err != nil {
        log.Fatalf("Failed to register component %s: %v", "database.Database", err)
    }

    // UserRepository (depends on Database)
    if err := cc.SetComponent(reflect.TypeOf((*repository.UserRepository)(nil)), &repository.UserRepository{}); err != nil {
        log.Fatalf("Failed to register component %s: %v", "repository.UserRepository", err)
    }

    // UserService (depends on UserRepository)
    if err := cc.SetComponent(reflect.TypeOf((*service.UserService)(nil)), &service.UserService{}); err != nil {
        log.Fatalf("Failed to register component %s: %v", "service.UserService", err)
    }

    // Initialize all components after registration
    return cc.InitializeComponents()
}
```

## How It Works

CtxBoot follows these steps to manage your components:

1. **Component Discovery**

   - Scans your codebase for structs with the `//ctxboot:component` annotation
   - Identifies fields tagged with `ctxboot:"inject"` as dependencies
   - Builds a dependency graph of your components

2. **Code Generation**

   - Generates a `ctxboot.go` file with:
     - Import statements for all component packages
     - A `LoadContext` function that registers components

3. **Component Registration**

   - When `LoadContext` is called, it:
     - Registers each component with its type
     - Skips registration if a component of the same type already exists

4. **Dependency Injection**

   - During initialization, it:
     - Processes components in dependency order
     - Injects dependencies by setting struct fields
     - Handles both pointer and non-pointer fields

5. **Component Access**
   - Components can be retrieved using `GetComponent`
   - The framework maintains a single context instance

## Usage

### 1. Define Components

Add the `ctxboot:component` annotation to your structs:

```go
//ctxboot:component
type Database struct {
    // Database implementation
}

//ctxboot:component
type UserRepository struct {
    DB *Database `ctxboot:"inject"`
}

//ctxboot:component
type UserService struct {
    Repo *UserRepository `ctxboot:"inject"`
}
```

### 2. Run the Code Generator

```bash
ctxboot ./path/to/your/package
```

This will generate a `ctxboot.go` file with component registration code.

### 3. Use in Your Application

```go
package main

import (
    "log"
    "github.com/iondodon/ctxboot"
)

func main() {
    // Register custom components before loading context
    cc := ctxboot.Boot()
    if err := cc.SetComponent(reflect.TypeOf((*CustomComponent)(nil)), &CustomComponent{}); err != nil {
        log.Fatalf("Failed to register custom component: %v", err)
    }

    // Load and initialize all components
    if err := LoadContext(cc); err != nil {
        log.Fatalf("Failed to load context: %v", err)
    }

    // Get a component instance
    service, err := cc.GetComponent(reflect.TypeOf((*UserService)(nil)))
    if err != nil {
        log.Fatalf("Failed to get service: %v", err)
    }

    // Use the component
    userService := service.(*UserService)
    // ... use userService
}
```

### 4. Interface-Based Component Retrieval

CtxBoot supports retrieving components by their interface type. This is useful for dependency injection based on interfaces and plugin architectures.

```go
// Define an interface
type Greeter interface {
    Greet() string
}

// Implement the interface
//ctxboot:component
type EnglishGreeter struct{}

func (g *EnglishGreeter) Greet() string {
    return "Hello!"
}

// Get component by interface type
greeter, err := cc.GetComponent(reflect.TypeOf((*Greeter)(nil)).Elem())
if err != nil {
    panic(err)
}

// Use the component
g := greeter.(Greeter)
fmt.Println(g.Greet())
```

Important notes about interface-based retrieval:

- If multiple components implement the same interface, the framework will panic (to avoid ambiguity)
- If no component implements the interface, you'll get an error
- The component is returned as `interface{}`, so you need to type assert it to your interface type
- This feature is particularly useful for:
  - Dependency injection based on interfaces
  - Plugin architectures
  - Service abstractions
  - Testing (easy implementation swapping)

### License

Apache License Version 2.0, January 2004
