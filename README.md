# CtxBoot

A lightweight dependency injection framework for Go.

## Installation

Install the code generator:

```bash
go install github.com/iondodon/ctxboot/cmd/ctxboot@latest
```

Then you can run it from project root directory:

```bash
ctxboot .
```

## Generated Code

The code generator creates a `ctxboot.go` file in your project. Here's what it contains:

```go
// Code generated by ctxboot; DO NOT EDIT.

package main

import (
    "github.com/iondodon/ctxboot"
    "reflect"
    "log"

    // Import statements for all component packages
    "your/package/database"
    "your/package/repository"
    "your/package/service"
)

// Context embeds ComponentContext and adds getter methods
type Context struct {
    *ctxboot.ComponentContext
}

// LoadContext registers and initializes all components and returns a Context
func LoadContext() (*Context, error) {
    cc := &Context{ctxboot.Boot()}

    // Register components in dependency order
    // Database (no dependencies)
    if err := cc.SetComponent(reflect.TypeOf((*database.Database)(nil)), &database.Database{}); err != nil {
        log.Fatalf("Failed to register component %s: %v", "database.Database", err)
    }

    // UserRepository (depends on Database)
    if err := cc.SetComponent(reflect.TypeOf((*repository.UserRepository)(nil)), &repository.UserRepository{}); err != nil {
        log.Fatalf("Failed to register component %s: %v", "repository.UserRepository", err)
    }

    // UserService (depends on UserRepository)
    if err := cc.SetComponent(reflect.TypeOf((*service.UserService)(nil)), &service.UserService{}); err != nil {
        log.Fatalf("Failed to register component %s: %v", "service.UserService", err)
    }

    // Initialize all components after registration
    if err := cc.InitializeComponents(); err != nil {
        return nil, err
    }

    return cc, nil
}

// Component getter methods
func (cc *Context) GetDatabase() (*database.Database, error) {
    component, err := cc.GetComponent(reflect.TypeOf((*database.Database)(nil)))
    if err != nil {
        return nil, err
    }
    return component.(*database.Database), nil
}

func (cc *Context) GetUserRepository() (*repository.UserRepository, error) {
    component, err := cc.GetComponent(reflect.TypeOf((*repository.UserRepository)(nil)))
    if err != nil {
        return nil, err
    }
    return component.(*repository.UserRepository), nil
}

func (cc *Context) GetUserService() (*service.UserService, error) {
    component, err := cc.GetComponent(reflect.TypeOf((*service.UserService)(nil)))
    if err != nil {
        return nil, err
    }
    return component.(*service.UserService), nil
}
```

## How It Works

CtxBoot follows these steps to manage your components:

1. **Component Discovery**

   - Scans your codebase for structs with the `//ctxboot:component` annotation
   - Identifies fields tagged with `ctxboot:"inject"` as dependencies
   - Builds a dependency graph of your components

2. **Code Generation**

   - Generates a `ctxboot.go` file with:
     - Import statements for all component packages
     - A `LoadContext` function that registers components

3. **Component Registration**

   - When `LoadContext` is called, it:
     - Registers each component with its type
     - Skips registration if a component of the same type already exists

4. **Dependency Injection**

   - During initialization, it:
     - Processes components in dependency order
     - Injects dependencies by setting struct fields
     - Handles both pointer and non-pointer fields

5. **Component Access**
   - Components can be retrieved using `GetComponent`
   - The framework maintains a single context instance

## Usage

### 1. Define Components

Add the `ctxboot:component` annotation to your structs:

```go
//ctxboot:component
type Database struct {
    // Database implementation
}

//ctxboot:component
type UserRepository struct {
    DB *Database `ctxboot:"inject"`
}

//ctxboot:component
type UserService struct {
    Repo *UserRepository `ctxboot:"inject"`
}
```

### 2. Run the Code Generator

```bash
ctxboot ./path/to/your/package
```

This will generate a `ctxboot.go` file with component registration code.

### 3. Use in Your Application

```go
package main

import (
    "log"
    "github.com/iondodon/ctxboot"
)

func main() {
    // Load context and get enhanced context with getter methods
    cc, err := LoadContext()
    if err != nil {
        log.Fatalf("Failed to load context: %v", err)
    }

    // Get a component instance using the generated getter method
    userService, err := cc.GetUserService()
    if err != nil {
        log.Fatalf("Failed to get service: %v", err)
    }

    // Use the component
    // ... use userService
}
```

The code generator automatically:

1. Creates a `Context` type that embeds `ComponentContext`
2. Generates getter methods for each component
3. Provides a simplified `LoadContext()` function

Benefits of the generated code:

- Type safety: Components are returned with the correct type
- No need for type assertions in your code
- Better IDE support with autocompletion
- Clearer error handling
- Simplified API with single initialization call

### Examples

#### Simple Example

```go
//ctxboot:component
type UserService struct {
    // Add fields as needed
}

func main() {
    cc, err := LoadContext()
    if err != nil {
        panic(err)
    }

    userService, err := cc.GetUserService()
    if err != nil {
        panic(err)
    }
    fmt.Println(userService.GetUser("123"))
}
```

#### Dependency Injection Example

```go
//ctxboot:component
type UserService struct {
    Repo *UserRepository `ctxboot:"inject"`
}

func main() {
    cc, err := LoadContext()
    if err != nil {
        panic(err)
    }

    userService, err := cc.GetUserService()
    if err != nil {
        panic(err)
    }
    fmt.Println(userService.GetUser("123"))
}
```

#### Interface-Based Example

```go
type Greeter interface {
    Greet() string
}

//ctxboot:component
type EnglishGreeter struct{}

func main() {
    cc, err := LoadContext()
    if err != nil {
        panic(err)
    }

    // Get by interface
    greeter, err := cc.GetComponent(reflect.TypeOf((*Greeter)(nil)).Elem())
    if err != nil {
        panic(err)
    }
    fmt.Println(greeter.(Greeter).Greet())

    // Or use generated getter
    englishGreeter, err := cc.GetEnglishGreeter()
    if err != nil {
        panic(err)
    }
    fmt.Println(englishGreeter.Greet())
}
```

### 4. Interface-Based Component Retrieval

CtxBoot supports retrieving components by their interface type. This is useful for dependency injection based on interfaces and plugin architectures.

```go
// Define an interface
type Greeter interface {
    Greet() string
}

// Implement the interface
//ctxboot:component
type EnglishGreeter struct{}

func (g *EnglishGreeter) Greet() string {
    return "Hello!"
}

// Get component by interface type
greeter, err := cc.GetComponent(reflect.TypeOf((*Greeter)(nil)).Elem())
if err != nil {
    panic(err)
}

// Use the component
g := greeter.(Greeter)
fmt.Println(g.Greet())
```

Important notes about interface-based retrieval:

- If multiple components implement the same interface, the framework will panic (to avoid ambiguity)
- If no component implements the interface, you'll get an error
- The component is returned as `interface{}`, so you need to type assert it to your interface type
- This feature is particularly useful for:
  - Dependency injection based on interfaces
  - Plugin architectures
  - Service abstractions
  - Testing (easy implementation swapping)

### License

Apache License Version 2.0, January 2004
