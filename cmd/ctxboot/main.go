package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

type Import struct {
	Path  string
	Alias string
}

type Component struct {
	Name         string
	Package      string
	File         string
	Dependencies []Dependency
	Alias        string
}

type Dependency struct {
	Name    string
	Package string
	File    string
}

type ComponentInfo struct {
	Package    string
	Components []Component
	Imports    []Import
	ModulePath string
}

const registrationTemplate = `// Code generated by ctxboot; DO NOT EDIT.

package main

import (
	"github.com/iondodon/ctxboot"
	"reflect"
	"log"
	{{range .Imports}}
	{{if .Alias}}{{.Alias}} {{end}}"{{.Path}}"
	{{end}}
)

// Context embeds ComponentContext and adds getter methods
type Context struct {
	*ctxboot.ComponentContext
}

// LoadContext registers and initializes all components and returns a Context
func LoadContext() (*Context, error) {
	cc := &Context{ctxboot.Boot()}
	
	// Register components in dependency order
	{{range .Components}}
	// Register {{if ne .Package "main"}}{{if .Alias}}{{.Alias}}.{{else}}{{.Package}}.{{end}}{{end}}{{.Name}}
	if err := cc.SetComponent(reflect.TypeOf((*{{if ne .Package "main"}}{{if .Alias}}{{.Alias}}.{{else}}{{.Package}}.{{end}}{{end}}{{.Name}})(nil)), &{{if ne .Package "main"}}{{if .Alias}}{{.Alias}}.{{else}}{{.Package}}.{{end}}{{end}}{{.Name}}{}); err != nil {
		log.Fatalf("Failed to register component %s: %v", "{{if ne .Package "main"}}{{if .Alias}}{{.Alias}}.{{else}}{{.Package}}.{{end}}{{end}}{{.Name}}", err)
	}
	{{end}}
	
	// Initialize all components after registration
	if err := cc.InitializeComponents(); err != nil {
		return nil, err
	}
	
	return cc, nil
}

// Component getter methods
{{range .Components}}
// Get{{.Name}} returns the {{.Name}} component
func (cc *Context) Get{{.Name}}() (*{{if ne .Package "main"}}{{if .Alias}}{{.Alias}}.{{else}}{{.Package}}.{{end}}{{end}}{{.Name}}, error) {
	component, err := cc.GetComponent(reflect.TypeOf((*{{if ne .Package "main"}}{{if .Alias}}{{.Alias}}.{{else}}{{.Package}}.{{end}}{{end}}{{.Name}})(nil)))
	if err != nil {
		return nil, err
	}
	return component.(*{{if ne .Package "main"}}{{if .Alias}}{{.Alias}}.{{else}}{{.Package}}.{{end}}{{end}}{{.Name}}), nil
}
{{end}}
`

// Find module root by looking for go.mod
func findModuleRoot(dir string) (string, error) {
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("go.mod not found")
		}
		dir = parent
	}
}

func main() {
	log.Println("Starting ctxboot code generation tool...")

	if len(os.Args) != 2 {
		log.Fatal("Usage: generate <package-dir>")
	}

	packageDir := os.Args[1]
	log.Printf("Starting scan from directory: %s", packageDir)
	components := make([]Component, 0)
	var packageName string

	// Find module root
	moduleRoot, err := findModuleRoot(packageDir)
	if err != nil {
		log.Fatalf("Failed to find module root: %v", err)
	}
	log.Printf("Found module root: %s", moduleRoot)

	// Read go.mod from module root
	modData, err := os.ReadFile(filepath.Join(moduleRoot, "go.mod"))
	if err != nil {
		log.Fatalf("Failed to read go.mod: %v", err)
	}
	modulePath := strings.TrimPrefix(strings.Split(string(modData), "\n")[0], "module ")

	// Collect unique imports with aliases for same-named packages
	imports := make(map[string]string) // map[importPath]alias
	nameCount := make(map[string]int)  // track how many times each name is used

	// Create a new token.FileSet to hold all parsed files
	fset := token.NewFileSet()

	// Walk through all subdirectories
	err = filepath.Walk(packageDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			log.Printf("Error accessing path %s: %v", path, err)
			return err
		}

		// Log directory traversal
		if info.IsDir() {
			log.Printf("Checking directory: %s", path)
			return nil
		}

		// Skip non-Go files
		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		log.Printf("Scanning file: %s", path)

		// Parse the Go file
		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			log.Printf("Warning: Failed to parse file %s: %v", path, err)
			return nil
		}

		// Use the first package name we find
		if packageName == "" {
			packageName = file.Name.Name
			log.Printf("Found package name: %s", packageName)
		}

		// Find components in the file
		componentCount := 0
		for _, decl := range file.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if hasComponentAnnotation(genDecl.Doc) {
							// Check if component is exported
							if !ast.IsExported(typeSpec.Name.Name) {
								log.Fatalf("Component %s must be exported (start with capital letter)", typeSpec.Name.Name)
							}

							componentCount++
							log.Printf("Found component: %s in file %s", typeSpec.Name.Name, path)

							// Get struct type
							structType, ok := typeSpec.Type.(*ast.StructType)
							if !ok {
								log.Printf("Warning: %s is not a struct type", typeSpec.Name.Name)
								continue
							}

							// Get dependencies
							deps := make([]Dependency, 0)
							for _, field := range structType.Fields.List {
								if field.Tag != nil {
									tag := strings.Trim(field.Tag.Value, "`")
									if strings.Contains(tag, `ctxboot:"inject"`) {
										// Get field type name
										switch t := field.Type.(type) {
										case *ast.StarExpr:
											switch x := t.X.(type) {
											case *ast.Ident:
												deps = append(deps, Dependency{
													Name:    x.Name,
													Package: file.Name.Name,
													File:    path,
												})
											case *ast.SelectorExpr:
												if pkg, ok := x.X.(*ast.Ident); ok {
													deps = append(deps, Dependency{
														Name:    x.Sel.Name,
														Package: pkg.Name,
														File:    path,
													})
												}
											}
										}
									}
								}
							}
							if len(deps) > 0 {
								log.Printf("Component %s has dependencies: %v", typeSpec.Name.Name, deps)
							}

							// Create component with alias if needed
							comp := Component{
								Name:         typeSpec.Name.Name,
								Package:      file.Name.Name,
								File:         path,
								Dependencies: deps,
								Alias:        imports[filepath.ToSlash(filepath.Join(modulePath, filepath.Dir(path)))],
							}
							components = append(components, comp)
						}
					}
				}
			}
		}
		if componentCount == 0 {
			log.Printf("No components found in file %s", path)
		} else {
			log.Printf("Found %d components in file %s", componentCount, path)
		}

		return nil
	})

	if err != nil {
		log.Fatalf("Failed to walk directory: %v", err)
	}

	if packageName == "" {
		log.Fatal("No Go files found in the specified directory")
	}

	log.Printf("Total components found: %d", len(components))

	// Sort components by dependencies
	sortedComponents := sortByDependencies(components)
	log.Printf("Sorted components: %v", sortedComponents)

	// Collect unique imports with aliases for same-named packages
	for _, comp := range components {
		if comp.Package != "main" {
			// Get the relative path from module root to the package
			relPath, err := filepath.Rel(moduleRoot, filepath.Dir(comp.File))
			if err != nil {
				log.Fatalf("Failed to get relative path: %v", err)
			}
			// Skip if the path is the module root itself
			if relPath != "." {
				// Normalize the path to use forward slashes
				normalizedPath := filepath.ToSlash(relPath)
				// Use the full module path for imports
				importPath := filepath.ToSlash(filepath.Join(modulePath, normalizedPath))

				// Get the last part of the path as the package name
				pkgName := filepath.Base(normalizedPath)
				nameCount[pkgName]++

				// If this name is used more than once, add an alias
				if nameCount[pkgName] > 1 {
					imports[importPath] = fmt.Sprintf("%s%d", pkgName, nameCount[pkgName])
				} else {
					imports[importPath] = pkgName
				}
			}
		}
		for _, dep := range comp.Dependencies {
			if dep.Package != "main" {
				// Get the relative path from module root to the package
				relPath, err := filepath.Rel(moduleRoot, filepath.Dir(dep.File))
				if err != nil {
					log.Fatalf("Failed to get relative path: %v", err)
				}
				// Skip if the path is the module root itself
				if relPath != "." {
					// Normalize the path to use forward slashes
					normalizedPath := filepath.ToSlash(relPath)
					// Use the full module path for imports
					importPath := filepath.ToSlash(filepath.Join(modulePath, normalizedPath))

					// Get the last part of the path as the package name
					pkgName := filepath.Base(normalizedPath)
					nameCount[pkgName]++

					// If this name is used more than once, add an alias
					if nameCount[pkgName] > 1 {
						imports[importPath] = fmt.Sprintf("%s%d", pkgName, nameCount[pkgName])
					} else {
						imports[importPath] = pkgName
					}
				}
			}
		}
	}

	// Convert imports map to slice and sort
	importsSlice := make([]Import, 0, len(imports))
	for path, alias := range imports {
		importsSlice = append(importsSlice, Import{Path: path, Alias: alias})
	}
	sort.Slice(importsSlice, func(i, j int) bool {
		return importsSlice[i].Path < importsSlice[j].Path
	})

	// Generate registration code
	info := ComponentInfo{
		Package:    packageName,
		Components: make([]Component, len(components)),
		Imports:    importsSlice,
		ModulePath: modulePath,
	}

	// Copy components with aliases for pointer fields
	for i, comp := range components {
		// Get the alias for this component's package
		compPath := filepath.ToSlash(filepath.Join(modulePath, filepath.Dir(comp.File)))
		alias := imports[compPath]

		info.Components[i] = Component{
			Name:         comp.Name,
			Package:      comp.Package,
			File:         comp.File,
			Dependencies: comp.Dependencies,
			Alias:        alias,
		}
	}

	tmpl, err := template.New("registration").Parse(registrationTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, info); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Write generated code
	outputFile := filepath.Join(packageDir, "ctxboot.go")
	if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
		log.Fatalf("Failed to write generated code: %v", err)
	}

	log.Printf("Successfully generated registration code in %s", outputFile)
}

func sortByDependencies(components []Component) []Component {
	// Create dependency graph with fully qualified names
	graph := make(map[string][]string)
	nameToComp := make(map[string]Component)

	for _, c := range components {
		fullName := c.Name
		if c.Package != "main" {
			fullName = c.Package + "." + c.Name
		}
		nameToComp[fullName] = c

		deps := make([]string, len(c.Dependencies))
		for i, dep := range c.Dependencies {
			deps[i] = dep.Package + "." + dep.Name
		}
		graph[fullName] = deps
	}

	// Perform topological sort
	visited := make(map[string]bool)
	temp := make(map[string]bool)
	sorted := make([]Component, 0)

	var visit func(name string) bool
	visit = func(name string) bool {
		if temp[name] {
			return false // Cycle detected
		}
		if visited[name] {
			return true
		}
		temp[name] = true

		for _, dep := range graph[name] {
			if !visit(dep) {
				return false
			}
		}

		delete(temp, name)
		visited[name] = true
		sorted = append(sorted, nameToComp[name])
		return true
	}

	for _, c := range components {
		fullName := c.Name
		if c.Package != "main" {
			fullName = c.Package + "." + c.Name
		}
		if !visit(fullName) {
			log.Fatalf("Cyclic dependency detected involving component %s", fullName)
		}
	}

	return sorted
}

func hasComponentAnnotation(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}
	for _, comment := range doc.List {
		if strings.Contains(comment.Text, "//ctxboot:component") {
			return true
		}
	}
	return false
}
