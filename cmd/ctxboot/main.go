package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const registrationTemplate = `// Code generated by ctxboot; DO NOT EDIT.

package {{.Package}}

import (
	"github.com/iondodon/ctxboot"
	"reflect"
)

func init() {
	cc := ctxboot.Boot()
	{{range .Components}}
	if err := cc.SetComponent(reflect.TypeOf(&{{.}}{}), &{{.}}{}); err != nil {
		panic(err)
	}
	{{end}}
}
`

type ComponentInfo struct {
	Package    string
	Components []string
}

type Component struct {
	Name         string
	Dependencies []string
}

func main() {
	if len(os.Args) != 2 {
		log.Fatal("Usage: generate <package-dir>")
	}

	packageDir := os.Args[1]
	components := make([]Component, 0)
	var packageName string

	// Create a new token.FileSet to hold all parsed files
	fset := token.NewFileSet()

	// Walk through all subdirectories
	err := filepath.Walk(packageDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories and non-Go files
		if info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		// Parse the Go file
		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			log.Printf("Warning: Failed to parse file %s: %v", path, err)
			return nil
		}

		// Use the first package name we find
		if packageName == "" {
			packageName = file.Name.Name
		}

		// Find components in the file
		for _, decl := range file.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if hasComponentAnnotation(genDecl.Doc) {
							// Get struct type
							structType, ok := typeSpec.Type.(*ast.StructType)
							if !ok {
								continue
							}

							// Get dependencies
							deps := make([]string, 0)
							for _, field := range structType.Fields.List {
								if field.Tag != nil {
									tag := strings.Trim(field.Tag.Value, "`")
									if strings.Contains(tag, `ctxboot:"inject"`) {
										// Get field type name
										switch t := field.Type.(type) {
										case *ast.StarExpr:
											if ident, ok := t.X.(*ast.Ident); ok {
												deps = append(deps, ident.Name)
											}
										}
									}
								}
							}

							components = append(components, Component{
								Name:         typeSpec.Name.Name,
								Dependencies: deps,
							})
						}
					}
				}
			}
		}

		return nil
	})

	if err != nil {
		log.Fatalf("Failed to walk directory: %v", err)
	}

	if packageName == "" {
		log.Fatal("No Go files found in the specified directory")
	}

	// Sort components by dependencies
	sortedComponents := sortByDependencies(components)

	// Generate registration code
	info := ComponentInfo{
		Package:    packageName,
		Components: sortedComponents,
	}

	tmpl, err := template.New("registration").Parse(registrationTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, info); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Write generated code
	outputFile := filepath.Join(packageDir, "ctxboot.go")
	if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
		log.Fatalf("Failed to write generated code: %v", err)
	}

	fmt.Printf("Generated registration code in %s\n", outputFile)
}

func sortByDependencies(components []Component) []string {
	// Create dependency graph
	graph := make(map[string][]string)
	for _, c := range components {
		graph[c.Name] = c.Dependencies
	}

	// Perform topological sort
	visited := make(map[string]bool)
	sorted := make([]string, 0)

	var visit func(name string)
	visit = func(name string) {
		if visited[name] {
			return
		}
		visited[name] = true

		for _, dep := range graph[name] {
			visit(dep)
		}
		sorted = append(sorted, name)
	}

	for _, c := range components {
		visit(c.Name)
	}

	return sorted
}

func hasComponentAnnotation(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}
	for _, comment := range doc.List {
		if strings.Contains(comment.Text, "//ctxboot:component") {
			return true
		}
	}
	return false
}
