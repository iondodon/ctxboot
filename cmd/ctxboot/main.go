package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const registrationTemplate = `// Code generated by ctxboot; DO NOT EDIT.

package main

import (
	"github.com/iondodon/ctxboot"
	"reflect"
	"log"
	{{range .Imports}}
	"{{.}}"
	{{end}}
)

func init() {
	cc := ctxboot.Boot()
	
	// Register components in dependency order
	{{range .Components}}
	// Register {{if ne .Package "main"}}{{.Package}}.{{end}}{{.Name}}
	if err := cc.SetComponent(reflect.TypeOf((*{{if ne .Package "main"}}{{.Package}}.{{end}}{{.Name}})(nil)), &{{if ne .Package "main"}}{{.Package}}.{{end}}{{.Name}}{}); err != nil {
		log.Fatalf("Failed to register component %s: %v", "{{if ne .Package "main"}}{{.Package}}.{{end}}{{.Name}}", err)
	}
	{{end}}
	
	// Initialize all components after registration
	if err := cc.InitializeComponents(); err != nil {
		log.Fatalf("Failed to initialize components: %v", err)
	}
}
`

type ComponentInfo struct {
	Package    string
	Components []Component
	Imports    []string
}

type Component struct {
	Name         string
	Package      string
	File         string
	Dependencies []Dependency
}

type Dependency struct {
	Name    string
	Package string
	File    string
}

// Find module root by looking for go.mod
func findModuleRoot(dir string) (string, error) {
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("go.mod not found")
		}
		dir = parent
	}
}

func main() {
	log.Println("Starting ctxboot code generation tool...")

	if len(os.Args) != 2 {
		log.Fatal("Usage: generate <package-dir>")
	}

	packageDir := os.Args[1]
	log.Printf("Starting scan from directory: %s", packageDir)
	components := make([]Component, 0)
	var packageName string

	// Create a new token.FileSet to hold all parsed files
	fset := token.NewFileSet()

	// Walk through all subdirectories
	err := filepath.Walk(packageDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			log.Printf("Error accessing path %s: %v", path, err)
			return err
		}

		// Log directory traversal
		if info.IsDir() {
			log.Printf("Checking directory: %s", path)
			return nil
		}

		// Skip non-Go files
		if !strings.HasSuffix(path, ".go") {
			return nil
		}

		log.Printf("Scanning file: %s", path)

		// Parse the Go file
		file, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			log.Printf("Warning: Failed to parse file %s: %v", path, err)
			return nil
		}

		// Use the first package name we find
		if packageName == "" {
			packageName = file.Name.Name
			log.Printf("Found package name: %s", packageName)
		}

		// Find components in the file
		componentCount := 0
		for _, decl := range file.Decls {
			if genDecl, ok := decl.(*ast.GenDecl); ok {
				for _, spec := range genDecl.Specs {
					if typeSpec, ok := spec.(*ast.TypeSpec); ok {
						if hasComponentAnnotation(genDecl.Doc) {
							// Check if component is exported
							if !ast.IsExported(typeSpec.Name.Name) {
								log.Fatalf("Component %s must be exported (start with capital letter)", typeSpec.Name.Name)
							}

							componentCount++
							log.Printf("Found component: %s in file %s", typeSpec.Name.Name, path)

							// Get struct type
							structType, ok := typeSpec.Type.(*ast.StructType)
							if !ok {
								log.Printf("Warning: %s is not a struct type", typeSpec.Name.Name)
								continue
							}

							// Get dependencies
							deps := make([]Dependency, 0)
							for _, field := range structType.Fields.List {
								if field.Tag != nil {
									tag := strings.Trim(field.Tag.Value, "`")
									if strings.Contains(tag, `ctxboot:"inject"`) {
										// Get field type name
										switch t := field.Type.(type) {
										case *ast.StarExpr:
											switch x := t.X.(type) {
											case *ast.Ident:
												deps = append(deps, Dependency{
													Name:    x.Name,
													Package: file.Name.Name,
													File:    path,
												})
											case *ast.SelectorExpr:
												if pkg, ok := x.X.(*ast.Ident); ok {
													deps = append(deps, Dependency{
														Name:    x.Sel.Name,
														Package: pkg.Name,
														File:    path,
													})
												}
											}
										}
									}
								}
							}
							if len(deps) > 0 {
								log.Printf("Component %s has dependencies: %v", typeSpec.Name.Name, deps)
							}

							components = append(components, Component{
								Name:         typeSpec.Name.Name,
								Package:      file.Name.Name,
								File:         path,
								Dependencies: deps,
							})
						}
					}
				}
			}
		}
		if componentCount == 0 {
			log.Printf("No components found in file %s", path)
		} else {
			log.Printf("Found %d components in file %s", componentCount, path)
		}

		return nil
	})

	if err != nil {
		log.Fatalf("Failed to walk directory: %v", err)
	}

	if packageName == "" {
		log.Fatal("No Go files found in the specified directory")
	}

	log.Printf("Total components found: %d", len(components))

	// Sort components by dependencies
	sortedComponents := sortByDependencies(components)
	log.Printf("Sorted components: %v", sortedComponents)

	// Find module root
	moduleRoot, err := findModuleRoot(packageDir)
	if err != nil {
		log.Fatalf("Failed to find module root: %v", err)
	}
	log.Printf("Found module root: %s", moduleRoot)

	// Read go.mod from module root
	modData, err := os.ReadFile(filepath.Join(moduleRoot, "go.mod"))
	if err != nil {
		log.Fatalf("Failed to read go.mod: %v", err)
	}
	modulePath := strings.TrimPrefix(strings.Split(string(modData), "\n")[0], "module ")

	// Collect unique imports
	imports := make(map[string]bool)
	for _, comp := range components {
		if comp.Package != "main" {
			// Get the relative path from module root to the package
			relPath, err := filepath.Rel(moduleRoot, filepath.Dir(comp.File))
			if err != nil {
				log.Fatalf("Failed to get relative path: %v", err)
			}
			// Skip if the path is the module root itself
			if relPath != "." {
				importPath := filepath.Join(modulePath, relPath)
				imports[importPath] = true
			}
		}
		for _, dep := range comp.Dependencies {
			if dep.Package != "main" {
				// Get the relative path from module root to the package
				relPath, err := filepath.Rel(moduleRoot, filepath.Dir(dep.File))
				if err != nil {
					log.Fatalf("Failed to get relative path: %v", err)
				}
				// Skip if the path is the module root itself
				if relPath != "." {
					importPath := filepath.Join(modulePath, relPath)
					imports[importPath] = true
				}
			}
		}
	}

	// Convert imports map to slice
	importsSlice := make([]string, 0, len(imports))
	for imp := range imports {
		importsSlice = append(importsSlice, imp)
	}

	// Generate registration code
	info := ComponentInfo{
		Package:    packageName,
		Components: components,
		Imports:    importsSlice,
	}

	tmpl, err := template.New("registration").Parse(registrationTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, info); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Write generated code
	outputFile := filepath.Join(packageDir, "ctxboot.go")
	if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
		log.Fatalf("Failed to write generated code: %v", err)
	}

	log.Printf("Successfully generated registration code in %s", outputFile)
}

func sortByDependencies(components []Component) []Component {
	// Create dependency graph with fully qualified names
	graph := make(map[string][]string)
	nameToComp := make(map[string]Component)

	for _, c := range components {
		fullName := c.Name
		if c.Package != "main" {
			fullName = c.Package + "." + c.Name
		}
		nameToComp[fullName] = c

		deps := make([]string, len(c.Dependencies))
		for i, dep := range c.Dependencies {
			deps[i] = dep.Package + "." + dep.Name
		}
		graph[fullName] = deps
	}

	// Perform topological sort
	visited := make(map[string]bool)
	temp := make(map[string]bool)
	sorted := make([]Component, 0)

	var visit func(name string) bool
	visit = func(name string) bool {
		if temp[name] {
			return false // Cycle detected
		}
		if visited[name] {
			return true
		}
		temp[name] = true

		for _, dep := range graph[name] {
			if !visit(dep) {
				return false
			}
		}

		delete(temp, name)
		visited[name] = true
		sorted = append(sorted, nameToComp[name])
		return true
	}

	for _, c := range components {
		fullName := c.Name
		if c.Package != "main" {
			fullName = c.Package + "." + c.Name
		}
		if !visit(fullName) {
			log.Fatalf("Cyclic dependency detected involving component %s", fullName)
		}
	}

	return sorted
}

func hasComponentAnnotation(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}
	for _, comment := range doc.List {
		if strings.Contains(comment.Text, "//ctxboot:component") {
			return true
		}
	}
	return false
}
