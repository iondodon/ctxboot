package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const registrationTemplate = `// Code generated by ctxboot; DO NOT EDIT.

package {{.Package}}

import (
	"github.com/iondodon/ctxboot"
	"reflect"
)

func init() {
	cc := ctxboot.Boot()
	{{range .Components}}
	if err := cc.SetComponent(reflect.TypeOf(&{{.}}{}), &{{.}}{}); err != nil {
		panic(err)
	}
	{{end}}
}
`

type ComponentInfo struct {
	Package    string
	Components []string
}

type Component struct {
	Name         string
	Dependencies []string
}

func main() {
	if len(os.Args) != 2 {
		log.Fatal("Usage: generate <package-dir>")
	}

	packageDir := os.Args[1]
	components := make([]Component, 0)
	var packageName string

	// Parse the package directory
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, packageDir, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse package: %v", err)
	}

	// Find components in each file
	for _, pkg := range pkgs {
		packageName = pkg.Name // Use the package name from the source
		for _, file := range pkg.Files {
			for _, decl := range file.Decls {
				if genDecl, ok := decl.(*ast.GenDecl); ok {
					for _, spec := range genDecl.Specs {
						if typeSpec, ok := spec.(*ast.TypeSpec); ok {
							if hasComponentAnnotation(genDecl.Doc) {
								// Get struct type
								structType, ok := typeSpec.Type.(*ast.StructType)
								if !ok {
									continue
								}

								// Get dependencies
								deps := make([]string, 0)
								for _, field := range structType.Fields.List {
									if field.Tag != nil {
										tag := strings.Trim(field.Tag.Value, "`")
										if strings.Contains(tag, `ctxboot:"inject"`) {
											// Get field type name
											switch t := field.Type.(type) {
											case *ast.StarExpr:
												if ident, ok := t.X.(*ast.Ident); ok {
													deps = append(deps, ident.Name)
												}
											}
										}
									}
								}

								components = append(components, Component{
									Name:         typeSpec.Name.Name,
									Dependencies: deps,
								})
							}
						}
					}
				}
			}
		}
	}

	// Sort components by dependencies
	sortedComponents := sortByDependencies(components)

	// Generate registration code
	info := ComponentInfo{
		Package:    packageName,
		Components: sortedComponents,
	}

	tmpl, err := template.New("registration").Parse(registrationTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, info); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Write generated code
	outputFile := filepath.Join(packageDir, "ctxboot.go")
	if err := os.WriteFile(outputFile, buf.Bytes(), 0644); err != nil {
		log.Fatalf("Failed to write generated code: %v", err)
	}

	fmt.Printf("Generated registration code in %s\n", outputFile)
}

func sortByDependencies(components []Component) []string {
	// Create dependency graph
	graph := make(map[string][]string)
	for _, c := range components {
		graph[c.Name] = c.Dependencies
	}

	// Perform topological sort
	visited := make(map[string]bool)
	sorted := make([]string, 0)

	var visit func(name string)
	visit = func(name string) {
		if visited[name] {
			return
		}
		visited[name] = true

		for _, dep := range graph[name] {
			visit(dep)
		}
		sorted = append(sorted, name)
	}

	for _, c := range components {
		visit(c.Name)
	}

	return sorted
}

func hasComponentAnnotation(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}
	for _, comment := range doc.List {
		if strings.Contains(comment.Text, "//ctxboot:component") {
			return true
		}
	}
	return false
}
